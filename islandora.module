<?php

/**
 * @file
 * Defines all the hooks this module implements.
 */

use Drupal\islandora\DublinCore;
use Drupal\islandora\Authentication\Provider\TokenAuth;
use Drupal\Core\Cache\Cache;
use Drupal\Core\Cache\CacheableMetadata;
use Drupal\Core\Cache\CacheableDependencyInterface;
use Drupal\islandora\Controller\DefaultController;

// @codingStandardsIgnoreStart
// Common datastreams.
const ISLANDORA_DS_COMP_STREAM = 'DS-COMPOSITE-MODEL';

// Permissions.
const ISLANDORA_VIEW_OBJECTS = 'view fedora repository objects';
const ISLANDORA_METADATA_EDIT = 'edit fedora metadata';
const ISLANDORA_ADD_DS = 'add fedora datastreams';
const ISLANDORA_INGEST = 'ingest fedora objects';
const ISLANDORA_PURGE = 'delete fedora objects and datastreams';
const ISLANDORA_MANAGE_PROPERTIES = 'manage object properties';
const ISLANDORA_VIEW_DATASTREAM_HISTORY = 'view old datastream versions';
const ISLANDORA_MANAGE_DELETED_OBJECTS = 'manage deleted objects';
const ISLANDORA_REVERT_DATASTREAM = 'revert to old datastream';
const ISLANDORA_REGENERATE_DERIVATIVES = 'regenerate derivatives for an object';
const ISLANDORA_REPLACE_DATASTREAM_CONTENT = 'replace a datastream with new content, preserving version history';
const ISLANDORA_MANAGE_ORPHANED_OBJECTS = 'view and delete a list of orphaned objects';

// Hooks.
const ISLANDORA_VIEW_HOOK = 'islandora_view_object';
const ISLANDORA_PRINT_HOOK = 'islandora_view_print_object';
const ISLANDORA_EDIT_HOOK = 'islandora_edit_object';
const ISLANDORA_OVERVIEW_HOOK = 'islandora_overview_object';
const ISLANDORA_PRE_INGEST_HOOK = 'islandora_ingest_pre_ingest';
const ISLANDORA_POST_INGEST_HOOK = 'islandora_ingest_post_ingest';
const ISLANDORA_PRE_PURGE_OBJECT_HOOK = 'islandora_pre_purge_object';
const ISLANDORA_POST_PURGE_OBJECT_HOOK = 'islandora_post_purge_object';
const ISLANDORA_UPDATE_RELATED_OBJECTS_PROPERTIES_HOOK = 'islandora_update_related_objects_properties';
const ISLANDORA_METADATA_OBJECT_ALTER = 'islandora_metadata_object';
const ISLANDORA_METADATA_OBJECT_DESCRIPTION_ALTER = 'islandora_metadata_object_description';
const ISLANDORA_BREADCRUMB_FILTER_PREDICATE_HOOK = 'islandora_get_breadcrumb_query_predicates';
const ISLANDORA_EDIT_DATASTREAM_REGISTRY_HOOK = 'islandora_edit_datastream_registry';

// @todo Add Documentation.
const ISLANDORA_OBJECT_INGESTED_HOOK = 'islandora_object_ingested';
const ISLANDORA_OBJECT_MODIFIED_HOOK = 'islandora_object_modified';
const ISLANDORA_OBJECT_PURGED_HOOK = 'islandora_object_purged';
const ISLANDORA_DATASTREAM_INGESTED_HOOK = 'islandora_datastream_ingested';
const ISLANDORA_DATASTREAM_MODIFIED_HOOK = 'islandora_datastream_modified';
const ISLANDORA_DATASTREAM_PURGED_HOOK = 'islandora_datastream_purged';
const ISLANDORA_INGEST_STEP_HOOK = 'islandora_ingest_steps';
const ISLANDORA_DERIVATIVE_CREATION_HOOK = 'islandora_derivative';

// Autocomplete paths.
const ISLANDORA_CONTENT_MODELS_AUTOCOMPLETE = 'islandora/autocomplete/content-models';
const ISLANDORA_MIME_TYPES_AUTOCOMPLETE = 'islandora/autocomplete/mime-types';

const ISLANDORA_BREADCRUMB_LEGACY_BACKEND = 'islandora_breadcrumbs_legacy_sparql';
// @codingStandardsIgnoreEnd

/**
 * Implements hook_theme().
 */
function islandora_theme() {
  return [
    // Default object template.
    'islandora_default' => [
      'file' => 'theme/theme.inc',
      'variables' => ['islandora_object' => NULL],
    ],
    // Admin table for solution pack viewer selection.
    'islandora_viewers_table' => [
      'file' => 'includes/solution_packs.inc',
      'render element' => 'form',
      'function' => 'theme_islandora_viewers_table',
    ],
    // Print used by the clipper.
    'islandora_object_print' => [
      'function' => 'theme_islandora_object_print',
      'file' => 'theme/theme.inc',
      'variables' => ['object' => NULL, 'content' => []],
    ],
    // Print object view, prints islandora objects.
    'islandora_object_print_object' => [
      'file' => 'theme/theme.inc',
      'template' => 'islandora-object-print',
      'variables' => [
        'object' => NULL,
        'content' => NULL,
        'metadata' => NULL,
        'islandora_content' => NULL,
      ],
    ],
    // Render a bunch of objects as either a grid or a list.
    'islandora_objects' => [
      'file' => 'theme/theme.inc',
      'template' => 'islandora-objects',
      'variables' => [
        'objects' => NULL,
        'display' => NULL,
        'page_size' => 20,
        'limit' => 12,
      ],
    ],
    // Render a bunch of objects as either a grid or a list.
    'islandora_objects_subset' => [
      'file' => 'theme/theme.inc',
      'template' => 'islandora-objects',
      'variables' => [
        'objects' => NULL,
        'display' => 'grid',
        'limit' => 10,
        'total' => NULL,
        'pager_element' => 0,
      ],
    ],
    // Render a bunch of objects as a grid.
    'islandora_objects_grid' => [
      'file' => 'theme/theme.inc',
      'template' => 'islandora-objects-grid',
      'variables' => ['objects' => NULL],
    ],
    // Render a bunch of objects as a list.
    'islandora_objects_list' => [
      'file' => 'theme/theme.inc',
      'template' => 'islandora-objects-list',
      'variables' => ['objects' => NULL],
    ],
    'islandora_dublin_core_display' => [
      'file' => 'theme/theme.inc',
      'template' => 'islandora-dublin-core-display',
      // We can add PIDs to the end of this pattern in our preprocess function
      // and templates will be able to have have a pid appended to the
      // template name to overide a template on a per object basis.
      // An example template might be named:
      // "islandora-dublin-core-display--islandora-27.tpl.php".
      'pattern' => 'islandora_dublin_core_display__',
      'variables' => [
        'islandora_object' => NULL,
        'print' => NULL,
      ],
    ],
    'islandora_dublin_core_description' => [
      'file' => 'theme/theme.inc',
      // We can add PIDs to the end of this pattern in our preprocess function
      // and templates will be able to have have a pid appended to the
      // template name to overide a template on a per object basis.
      // An example template might be named:
      // "islandora-dublin-core-description--islandora-27.tpl.php".
      'pattern' => 'islandora_dublin_core_description__',
      'variables' => ['islandora_object' => NULL],
    ],
    // Table for install/reinstall content model and collections.
    'islandora_solution_pack_table' => [
      'file' => 'includes/solution_packs.inc',
      'render element' => 'form',
    ],
  ];
}

/**
 * View print tab access.
 *
 * Configurable option in Islandora configuration.
 *
 * @param string $op
 *   String identifying an operation to check. Should correspond to a
 *   permission declared via hook_permission().
 * @param AbstractObject $object
 *   An object to check for permissions.
 *
 * @return bool
 *   TRUE if at least one implementation of hook_islandora_object_access()
 *   returned TRUE, and no implementation return FALSE; FALSE otherwise, or
 *   FALSE if 'islandora_show_print_option' is not selected in islandora
 *   configuraton.
 */
function islandora_print_object_access($op, AbstractObject $object) {
  if (!\Drupal::config('islandora.settings')->get('islandora_show_print_option')) {
    return FALSE;
  }
  $access = islandora_object_access($op, $object);
  return $access;
}

/**
 * Implements hook_forms().
 */
function islandora_forms($form_id) {
  $forms = [];
  if (strpos($form_id, 'islandora_solution_pack_form_') !== FALSE) {
    $forms[$form_id] = ['callback' => 'islandora_solution_pack_form'];
  }
  return $forms;
}

/**
 * Checks whether the user can access the given object.
 *
 * Checks for repository access, object/datastream existance, namespace access,
 * user permissions, content models.
 *
 * Will check the given user or the user repersented by the GET token parameter,
 * failing that it will use the current user.
 *
 * @param mixed $object_or_datastream
 *   The AbstractObject or AbstractDatastream to test for accessibility, if NULL
 *   is given the object is assumed to not exist or be inaccessible.
 * @param array $permissions
 *   The required user permissions.
 * @param array $content_models
 *   The required content models.
 * @param bool $access_any
 *   (optional) TRUE to grant access if any single requirement is met from both
 *   the permissions and content models parameters. FALSE if all requirements
 *   must be met from both the permissions and content model parameters.
 * @param object $user
 *   (optional) The account to check, if not given check the GET parameters for
 *   a token to restore the user. If no GET parameter is present use currently
 *   logged in user.
 *
 * @return bool
 *   TRUE if the user is allowed to access this object/datastream, FALSE
 *   otherwise.
 */
function islandora_user_access_check($object_or_datastream, array $permissions, array $content_models = [], $access_any = TRUE, $user = NULL) {
  module_load_include('inc', 'islandora', 'includes/utilities');
  $is_repository_accessible = &drupal_static(__FUNCTION__);

  // If the repository is inaccessible then access always fails.
  if (!isset($is_repository_accessible)) {
    $is_repository_accessible = islandora_describe_repository();
    if (!$is_repository_accessible) {
      // Only display the inaccessible message once.
      islandora_display_repository_inaccessible_message();
      return FALSE;
    }
  }
  if (!$is_repository_accessible || !is_object($object_or_datastream) || empty($permissions)) {
    return FALSE;
  }

  // Determine what has been passed as $object.
  if (is_subclass_of($object_or_datastream, 'AbstractObject')) {
    $object = $object_or_datastream;
    $datastream = NULL;
  }
  elseif (is_subclass_of($object_or_datastream, 'AbstractDatastream')) {
    $datastream = $object_or_datastream;
    $object = $datastream->parent;
  }

  // Determine the user account to test against.
  if (!isset($user)) {
    $token = filter_input(INPUT_GET, TokenAuth::TOKEN_NAME, FILTER_SANITIZE_STRING);
    if ($token) {
      module_load_include('inc', 'islandora', 'includes/authtokens');
      $token_user = islandora_validate_object_token($object->id, $datastream->id, $token);
      if ($user) {
        $user = \Drupal::entityManager()->getStorage('user')->load($token_user->id());
      }
    }
    else {
      $user = \Drupal::currentUser();
    }
  }

  // Check for access.
  if ($access_any) {
    $has_required_content_models = empty($content_models) ? TRUE : count(array_intersect($object->models, $content_models)) > 0;
    if ($has_required_content_models) {
      foreach ($permissions as $p) {
        if ($datastream !== NULL) {
          $check = islandora_datastream_access($p, $datastream, $user);
        }
        else {
          $check = islandora_object_access($p, $object, $user);
        }

        if ($check) {
          return TRUE;
        }
      }
      return FALSE;
    }
  }
  else {
    $has_required_content_models = count(array_diff($content_models, $object->models)) == 0;
    if ($has_required_content_models) {
      foreach ($permissions as $p) {
        if ($datastream !== NULL) {
          $check = islandora_datastream_access($p, $datastream, $user);
        }
        else {
          $check = islandora_object_access($p, $object, $user);
        }

        if (!$check) {
          return FALSE;
        }
      }
      // Should already have failed if there are no $permissions.
      return TRUE;
    }
  }
  return FALSE;
}

/**
 * Checks whether the user can access the given object and datastream.
 *
 * This function will validate and use a token if present in the GET parameters.
 *
 * Checks for object existance, accessibility, namespace permissions,
 * and user permissions
 */
function islandora_object_datastream_tokened_access_callback($perm, $object = NULL, $datastream = NULL) {
  module_load_include('inc', 'islandora', 'includes/utilities');

  // Token validation requires a valid object and PID in order to make a
  // potential match in the db.
  $token_account = NULL;
  if (is_object($object) && is_object($datastream)) {
    $token = filter_input(INPUT_GET, TokenAuth::TOKEN_NAME, FILTER_SANITIZE_STRING);

    if ($token) {
      $user = islandora_validate_object_token($object->id, $datastream->id, $token);
      if ($user) {
        $token_account = \Drupal::entityManager()->getStorage('user')->load($user->id());
      }
    }
  }

  return islandora_datastream_access($perm, $datastream, $token_account);
}

/**
 * Checks whether the user can access the given object's manage tab.
 *
 * Checks for object existance, accessiblitly, namespace permissions,
 * and user permissions.
 *
 * @param array $perms
 *   Array of user permission to test for.
 * @param null|AbstractObject $object
 *   The object to test, if NULL given the object doesn't exist or is
 *   inaccessible.
 *
 * @return bool
 *   TRUE if the user is allowed to access this object, FALSE otherwise.
 */
function islandora_object_manage_access_callback(array $perms, $object = NULL) {
  module_load_include('inc', 'islandora', 'includes/utilities');

  if (!$object && !islandora_describe_repository()) {
    islandora_display_repository_inaccessible_message();
    return FALSE;
  }

  $has_access = FALSE;
  for ($i = 0; $i < count($perms) && !$has_access; $i++) {
    $has_access = $has_access || islandora_object_access($perms[$i], $object);
  }

  return $has_access;
}

/**
 * Renders the default view object page for the given object.
 *
 * @param AbstractObject $object
 *   The object used to render the view object page.
 *
 * @return array
 *   The default rendering of the object view page, indexed at 'Default output'.
 */
function islandora_default_islandora_view_object(AbstractObject $object) {
  return [
    'Default output' => [
      '#theme' => 'islandora_default',
      '#islandora_object' => $object,
    ],
  ];
}

/**
 * Append the image alter to the printable form.
 *
 * @param AbstractObject $object
 *   The fedora object to print.
 * @param string $alter
 *   The string representation of the themed viewable object.
 *
 * @return array
 *   A renderable array.
 */
function islandora_default_islandora_printer_object(AbstractObject $object, $alter) {
  module_load_include('inc', 'islandora', 'includes/utilities');
  module_load_include('inc', 'islandora', 'includes/datastream');
  module_load_include('inc', 'islandora', 'includes/metadata');

  $islandora_object = islandora_object_load($object->id);

  try {
    $dc = $islandora_object['DC']->content;
    $dc_object = DublinCore::importFromXmlString($dc);
  }
  catch (Exception $e) {
    drupal_set_message(t('Error retrieving object %s %t', ['%s' => $islandora_object->id, '%t' => $e->getMessage()]), 'error', FALSE);
  }
  $metadata = islandora_retrieve_metadata_markup($object, TRUE);
  $variables = isset($dc_object) ? $dc_object->asArray() : [];
  $output = [
    '#theme' => 'islandora_object_print_object',
    '#attached' => ['library' => ['islandora/islandora-print']],
    '#object' => $object,
    '#dc_array' => $variables,
    '#metadata' => $metadata,
    '#islandora_content' => $alter,
  ];

  return ['Default output' => ['#markup' => \Drupal::service('renderer')->render($output)]];
}

/**
 * Just a wrapper around fetchings the IslandoraTuque object.
 *
 * Includes some very basic error logging.
 *
 * @param object $user
 *   The user to connect as.
 * @param string $url
 *   The URL to connect to.
 *
 * @return IslandoraTuque
 *   A IslandoraTuque instance
 */
function islandora_get_tuque_connection($user = NULL, $url = NULL) {
  module_load_include('inc', 'islandora', 'includes/tuque');
  $tuque = &drupal_static(__FUNCTION__);
  if (!$tuque) {
    if (IslandoraTuque::exists()) {
      try {
        $tuque = new IslandoraTuque($user, $url);
      }
      catch (Exception $e) {
        drupal_set_message(t('Unable to connect to the repository %e', ['%e' => $e]), 'error');
      }
    }
    else {
      return NULL;
    }
  }
  return $tuque;
}

/**
 * Loads the object from the given ID if possible.
 *
 * Often used to get a connection and return an object for the one specified in
 * the menu path as '%islandora_object'.
 *
 * @param string $object_id
 *   The pid of an object in the menu path identified by '%islandora_object'.
 *
 * @return FedoraObject
 *   If the given object id exists in the repository then this returns a
 *   FedoraObject.
 *   If no object was found it returns FALSE.
 *   If the object was inaccessible then NULL is returned.
 */
function islandora_object_load($object_id) {
  $tuque = islandora_get_tuque_connection();
  if ($tuque) {
    try {
      return $tuque->repository->getObject(urldecode($object_id));
    }
    catch (Exception $e) {
      if ($e->getCode() == '404') {
        return FALSE;
      }
      else {
        return NULL;
      }
    }
  }
  else {
    IslandoraTuque::getError();
  }
  // Assuming access denied in all other cases for now.
  return NULL;
}

/**
 * Load the the object using a token if passed as a GET parameter.
 *
 * A helper function to get a connection and return an object using a token
 * for authentication.
 *
 * @param string $object_id
 *   The PID of an object in the menu path identified by
 *   '%islandora_tokened_object'.
 * @param array $map
 *   Used to extract the Fedora object's DSID at $map[4].
 *
 * @return FedoraObject
 *   A token authenticated object. @see islandora_object_load
 */
function islandora_tokened_object_load($object_id, array $map) {
  if (array_key_exists('token', $_GET)) {
    $token = filter_input(INPUT_GET, TokenAuth::TOKEN_NAME, FILTER_SANITIZE_STRING);
    if ($token) {
      module_load_include('inc', 'islandora', 'includes/authtokens');
      $token_user = islandora_validate_object_token($object_id, $map[4], $token);
      $token_user = $token_user ? \Drupal::entityManager()->getStorage('user')->load($token_user->id()) : NULL;
      islandora_get_tuque_connection($token_user);
    }
  }
  return islandora_object_load($object_id);
}

/**
 * Fetches a datastream object.
 *
 * This datastream load must take in arguments in a different
 * order than the usual islandora_datastream_load.  This is because
 * the function islandora_tokened_object_load needs DSID. It uses
 * the path %map to avoid duplicate parameters. The menu system
 * passes 'load arguments' to both islandora_tokened_object_load
 * and this function and the first parameter is positional with the token.
 * An alternative:
 * islandora_tokened_object_load(PID, DSID, PID)
 * islandora_tokened_datastream_load(DSID, DSID, PID)
 *
 * @param mixed $datastream_id
 *   Param islandora_tokened_datastream @see islandora_datastream_load.
 * @param array $map
 *   Used to extract the Fedora object's PID at $map[2].
 *
 * @return FedoraDatastream
 *   A datastream from Fedora.
 *
 * @see islandora_datastream_load
 */
function islandora_tokened_datastream_load($datastream_id, array $map) {
  return islandora_datastream_load($datastream_id, $map[2]);
}

/**
 * Fetches a datastream object.
 *
 * A helper function to get an datastream specified as '%islandora_datastream'
 * for the object specified in the menu path as '%islandora_object'.
 *
 * Its up to the access callbacks and menu callbacks to trigger
 * drupal_access_denied() when appropriate.
 *
 * @param string $datastream_id
 *   The DSID of the datastream specified as '%islandora_datastream' to fetch
 *   from the given object in the menu path identified by '%islandora_object'.
 * @param mixed $object_id
 *   The object to load the datastream from.  This can be a Fedora PID or
 *   an instantiated IslandoraAbstractObject as it implements __toString()
 *   returning the PID.
 *
 * @return FedoraDatastream
 *   If the given datastream ID exists then this returns a FedoraDatastream
 *   object, otherwise it returns NULL.
 */
function islandora_datastream_load($datastream_id, $object_id) {
  $object = is_object($object_id) ? $object_id : islandora_object_load($object_id);
  if (!$object) {
    return NULL;
  }
  return $object[$datastream_id];
}

/**
 * Fetches the given datastream version from its datastream.
 *
 * Content model, collection view and collection policy datastreams may now
 * optionally define a version number in their top-level XML element as an
 * attribute, as in:
 *   <content_model name="Collection" version="2" ...
 *
 * @param null|AbstractObject $object
 *   The Object the datastream belongs to.
 * @param string $dsid
 *   The ID of the datastream.
 * @param string $datastream_file
 *   The datastream's content.
 *
 * @return int
 *   The datastreams version if found, NULL otherwise.
 */
function islandora_get_islandora_datastream_version($object = NULL, $dsid = NULL, $datastream_file = NULL) {
  $return = NULL;
  // @TODO, need better check for $object
  if ($object && $object[$dsid]) {
    $doc = simplexml_load_string($object[$dsid]->content);
  }
  elseif (!empty($datastream_file)) {
    $doc = simplexml_load_file($datastream_file);
  }

  if (!empty($doc) && $version = (int) $doc->attributes()->version) {
    $return = $version;
  }

  return $return;
}

/**
 * Implements hook_islandora_required_objects().
 */
function islandora_islandora_required_objects(IslandoraTuque $connection) {
  $module_path = drupal_get_path('module', 'islandora');
  // Root Collection.
  $root_collection = $connection->repository->constructObject('islandora:root');
  $root_collection->owner = 'fedoraAdmin';
  $root_collection->label = 'Top-level Collection';
  $root_collection->models = 'islandora:collectionCModel';
  // Collection Policy Datastream.
  $datastream = $root_collection->constructDatastream('COLLECTION_POLICY', 'M');
  $datastream->label = 'Collection policy';
  $datastream->mimetype = 'application/xml';
  $datastream->setContentFromFile("$module_path/xml/islandora_collection_policy.xml", FALSE);
  $root_collection->ingestDatastream($datastream);
  // TN Datastream.
  $datastream = $root_collection->constructDatastream('TN', 'M');
  $datastream->label = 'Thumbnail';
  $datastream->mimetype = 'image/png';
  $datastream->setContentFromFile("$module_path/images/folder.png", FALSE);
  $root_collection->ingestDatastream($datastream);
  return [
    'islandora' => [
      'title' => 'Islandora',
      'objects' => [$root_collection],
    ],
  ];
}

/**
 * Implements hook_islandora_undeleteable_datastreams().
 */
function islandora_islandora_undeletable_datastreams(array $models) {
  return ['DC', 'RELS-EXT'];
}

/**
 * Ingest the given object.
 *
 * @param AbstractObject $object
 *   An ingestable FedoraObject.
 *
 * @return FedoraObject
 *   The ingested FedoraObject.
 */
function islandora_add_object(AbstractObject &$object) {
  return $object->repository->ingestObject($object);
}

/**
 * Creates a new object with the same properties as the old.
 *
 * @todo Make Tuque objects support cloneing.
 *
 * @param AbstractObject $object
 *   An existing or new Fedora Object.
 *
 * @return AbstractObject
 *   The new Fedora Object with properties identical to the object given. This
 *   returned object is not automatically ingested.
 */
function islandora_copy_object(AbstractObject $object) {
  $clone = $object->repository->constructObject($object->id);
  $object_properties = [
    'state',
    'createdDate',
    'lastModifiedDate',
    'label',
    'owner',
    'logMessage',
  ];
  // Copy Properties.
  foreach ($object_properties as $property) {
    if (isset($object->$property)) {
      $clone->$property = $object->$property;
    }
  }
  // Copy Datastreams.
  foreach ($object as $dsid => $datastream) {
    if (empty($clone[$dsid])) {
      $clone->ingestDatastream($datastream);
    }
    else {
      // Get the content into a file, and add the file.
      $temp_file = \Drupal::service("file_system")->tempnam('temporary://', 'datastream');
      $datastream->getContent($temp_file);
      $clone[$dsid]->setContentFromFile($temp_file);
      \Drupal::service("file_system")->unlink($temp_file);
    }
  }
  return $clone;
}

/**
 * Delete's or purges the given object.
 *
 * @param AbstractObject $object
 *   An object to delete.
 *
 * @return bool
 *   TRUE if successful, FALSE otherwise.
 */
function islandora_delete_object(AbstractObject &$object) {
  try {
    $object->repository->purgeObject($object->id);
    $object = NULL;
    return TRUE;
  }
  catch (Exception $e) {
    // Exception message gets logged in Tuque Wrapper.
    return FALSE;
  }
}

/**
 * Delete's or purges the given datastream.
 *
 * @param AbstractDatastream $datastream
 *   The datastream to delete.
 *
 * @return bool
 *   TRUE if successful, FALSE otherwise.
 *
 * @throws Exception
 *   Which types are undefined, but more than likely because of the hooks
 *   there will be several kinds.
 */
function islandora_delete_datastream(AbstractDatastream &$datastream) {
  $object = $datastream->parent;
  return $object->purgeDatastream($datastream->id);
}

/**
 * Implements hook_cron().
 */
function islandora_cron() {
  TokenAuth::removeExpiredTokens();
}

/**
 * Implements hook_file_mimetype_mapping_alter().
 *
 * Grab custom Islandora mime type list
 * and add any missing ext/mimes to the Drupal mapping.
 */
function islandora_file_mimetype_mapping_alter(&$mapping) {
  module_load_include('inc', 'islandora', 'includes/mimetype.utils');

  $types = islandora_mime_mapping();

  $diff = array_diff_key($types, $mapping['extensions']);
  foreach ($diff as $ext => $mime) {
    $mapping['mimetypes'][] = $mime;
    end($mapping['mimetypes']);
    $mapping['extensions'][$ext] = key($mapping['mimetypes']);
  }
  // Get the current XML mapping and unset it so it comes last when we do our
  // reverse when getting mimetypes from extensions for use in downloads.
  // @see islandora_get_extension_for_mimetype.
  $xml_int = $mapping['extensions']['xml'];
  unset($mapping['extensions']['xml']);
  $mapping['extensions']['xml'] = $xml_int;
}

/**
 * Hookable object access callback.
 *
 * @param string $op
 *   String identifying an operation to check. Should correspond to a
 *   permission declared via hook_permission().
 * @param AbstractObject $object
 *   An object to check for permissions.
 * @param null|\Drupal\Core\Session\AccountProxyInterface $account
 *   An optional loaded user object. Defaults to the current user.
 *
 * @return bool
 *   TRUE if at least one implementation of hook_islandora_object_access()
 *   returned TRUE, and no implementation return FALSE; FALSE otherwise.
 */
function islandora_object_access($op, AbstractObject $object, $account = NULL) {
  $cache = &drupal_static(__FUNCTION__);
  if (!is_object($object)) {
    // The object could not be loaded... Presumably, we don't have
    // permission.
    return FALSE;
  }
  if ($account === NULL) {
    $account = \Drupal::currentUser();
  }
  // Populate the cache on a miss.
  if (!isset($cache[$op][$object->id][$account->id()])) {
    module_load_include('inc', 'islandora', 'includes/utilities');

    $results = islandora_invoke_hook_list('islandora_object_access', $object->models, [
      $op,
      $object,
      $account,
    ]);
    // Nothing returned FALSE, and something returned TRUE.
    $cache[$op][$object->id][$account->id()] = (!in_array(FALSE, $results, TRUE) && in_array(TRUE, $results, TRUE));
  }
  return $cache[$op][$object->id][$account->id()];
}

/**
 * Implements hook_islandora_object_access().
 *
 * Denies according to PID namespace restrictions, then passes or denies
 * according to core Drupal permissions according to user_access().
 */
function islandora_islandora_object_access($op, $object, $user) {
  module_load_include('inc', 'islandora', 'includes/utilities');
  return islandora_namespace_accessible($object->id) && $user->hasPermission($op);
}

/**
 * Hookable access callback for datastreams.
 *
 * Positive permissions on object access suggests on the datastream.
 */
function islandora_datastream_access($op, $datastream, $user = NULL) {
  $cache = &drupal_static(__FUNCTION__);
  if (!is_object($datastream)) {
    // The object could not be loaded... Presumably, we don't have
    // permission.
    return NULL;
  }
  if ($user === NULL) {
    $user = \Drupal::currentUser();
  }

  // Populate the cache on a miss.
  if (!isset($cache[$op][$datastream->parent->id][$datastream->id][$user->id()])) {
    module_load_include('inc', 'islandora', 'includes/utilities');

    $datastream_results = islandora_invoke_hook_list('islandora_datastream_access', $datastream->parent->models, [
      $op,
      $datastream,
      $user,
    ]);

    // The datastream check returned no FALSE, and at least one TRUE.
    $cache[$op][$datastream->parent->id][$datastream->id][$user->id()] = (
      !in_array(FALSE, $datastream_results, TRUE) && in_array(TRUE, $datastream_results, TRUE)
    );
  }
  return $cache[$op][$datastream->parent->id][$datastream->id][$user->id()];
}

/**
 * Implements hook_islandora_basic_collection_get_query_filters().
 */
function islandora_islandora_basic_collection_get_query_filters() {
  module_load_include('inc', 'islandora', 'includes/utilities');
  $enforced = \Drupal::config('islandora.settings')->get('islandora_namespace_restriction_enforced');
  if ($enforced) {
    $namespace_array = islandora_get_allowed_namespaces();
    $namespace_sparql = implode('|', $namespace_array);
    return ['islandora_namespace_restrictions' => strtr('regex(str(?object), "info:fedora/(!namespaces):")', ['!namespaces' => $namespace_sparql])];
  }
}

/**
 * Implements hook_islandora_object_ingested().
 *
 * On object ingestion we call the case of source_dsid being NULL only as
 * the islandora_islandora_datastream_ingested hook will handle the cases
 * where specific values of source_dsid can occur.
 */
function islandora_islandora_object_ingested(AbstractObject $object) {
  module_load_include('inc', 'islandora', 'includes/derivatives');
  // Defer derivatives if necessary.
  if (islandora_get_defer_derivatives_flag($object)) {
    return;
  }
  islandora_run_derivatives($object, NULL);

  $cache_meta = CacheableMetadata::createFromObject($object);
  islandora_conditionally_clear_cache($cache_meta);
}

/**
 * Implements hook_islandora_object_modified().
 */
function islandora_islandora_object_modified(AbstractObject $object) {
  $cache_meta = CacheableMetadata::createFromObject($object);

  islandora_conditionally_clear_cache($cache_meta);
}

/**
 * Implements hook_islandora_datastream_ingested().
 *
 * When a datastream is ingested we filter the derivatives on source_dsid being
 * equal to the current ingested datastream's id.
 */
function islandora_islandora_datastream_ingested(AbstractObject $object, AbstractDatastream $datastream) {
  module_load_include('inc', 'islandora', 'includes/derivatives');
  // Defer derivatives if necessary.
  if (islandora_get_defer_derivatives_flag($object)) {
    return;
  }
  islandora_run_derivatives($object, $datastream->id);

  $cache_meta = CacheableMetadata::createFromObject($object)
    ->addCacheableDependency($datastream);

  islandora_conditionally_clear_cache($cache_meta);
}

/**
 * Implements hook_islandora_datastream_modified().
 *
 * When a datastream is modified we filter the derivatives on source_dsid being
 * equal to the current ingested datastream's id. Force is set to TRUE such that
 * existing derivatives will be updated to reflect the change in the source.
 */
function islandora_islandora_datastream_modified(AbstractObject $object, AbstractDatastream $datastream, $params) {
  module_load_include('inc', 'islandora', 'includes/derivatives');
  $params += [
    'dsid' => $datastream->id,
  ];
  $logging_results = islandora_do_derivatives($object, [
    'source_dsid' => $datastream->id,
    'force' => TRUE,
    'ds_modified_params' => $params,
  ]);
  islandora_derivative_logging($logging_results);

  $cache_meta = CacheableMetadata::createFromObject($object)
    ->addCacheableDependency($datastream);

  islandora_conditionally_clear_cache($cache_meta);
}

/**
 * Implements hook_islandora_object_purged().
 */
function islandora_islandora_object_purged($pid) {
  $cache_meta = CacheableMetadata::createFromRenderArray([
    '#cache' => [
      'tags' => [
        $pid,
      ],
    ],
  ]);
  islandora_conditionally_clear_cache($cache_meta);
}

/**
 * Implements hook_islandora_datastream_purged().
 */
function islandora_islandora_datastream_purged(AbstractObject $object, $dsid) {
  $cache_meta = CacheableMetadata::createFromObject($object)
    ->addCacheTags([
      "{$object->id}/{$dsid}",
    ]);
  islandora_conditionally_clear_cache($cache_meta);
}

/**
 * Implements hook_islandora_metadata_display_info().
 */
function islandora_islandora_metadata_display_info() {
  return [
    'dublin_core' => [
      'label' => t('Dublin Core'),
      'description' => t('Dublin Core metadata'),
      'metadata callback' => 'islandora_metadata_display_renderable_callback',
      'description callback' => 'islandora_metadata_description_callback',
    ],
  ];
}

/**
 * Implements hook_islandora_datastream_access().
 */
function islandora_islandora_datastream_access($op, AbstractDatastream $datastream, $user) {
  module_load_include('inc', 'islandora', 'includes/utilities');
  $result = islandora_object_access($op, $datastream->parent, $user);

  if ($result && $op == ISLANDORA_REGENERATE_DERIVATIVES) {
    module_load_include('inc', 'islandora', 'includes/derivatives');
    $applicable_hook = FALSE;
    $object = $datastream->parent;
    $hooks = islandora_invoke_hook_list(ISLANDORA_DERIVATIVE_CREATION_HOOK, $object->models, [$object]);
    $hooks = islandora_filter_derivatives($hooks, ['force' => TRUE], $object);
    foreach ($hooks as $hook) {
      if (isset($hook['destination_dsid']) && $hook['destination_dsid'] == $datastream->id &&
        (is_null($hook['source_dsid']) || islandora_datastream_access(ISLANDORA_VIEW_OBJECTS, $object[$hook['source_dsid']], $user))) {
        $applicable_hook = TRUE;
        break;
      }
    }
    if (!$applicable_hook) {
      $result = FALSE;
    }
  }
  return $result;
}

/**
 * Access for submenu items.
 *
 * @param string $package_name
 *   Name of the package.
 *
 * @return bool
 *   Access granted
 */
function islandora_find_package($package_name) {
  $results = system_get_info('module');
  $found = FALSE;
  foreach ($results as $values) {
    if ($values['package'] == $package_name) {
      $found = TRUE;
      break;
    }
  }
  return $found && \Drupal::currentUser()->hasPermission('administer site configuration');
}

/**
 * Helper function for ingest steps and batches.
 *
 * When batches within batches are triggered within ingest steps
 * the submit handler becomes out of scope. When it becomes time to execute the
 * submit the function cannot be found and fails. This pre-submit is to
 * get around this problem.
 *
 * @see https://www.drupal.org/node/2300367
 *
 * @see https://www.drupal.org/node/1300928
 */
function islandora_ingest_form_pre_submit($form, &$form_state) {
  module_load_include('inc', 'islandora', 'includes/ingest.form');
}

/**
 * Implements hook_menu_local_tasks_alter().
 *
 * Replaces the print link text with an icon.
 */
function islandora_menu_local_tasks_alter(&$data, $route_name) {
  if (!isset($data['tabs'][0]) || !is_array($data['tabs'][0])) {
    return;
  }
  $tabs = &$data['tabs'][0];
  if ($route_name != 'islandora.printer_object' && in_array('islandora.printer_object', array_keys($tabs))) {
    $tab = &$tabs['islandora.printer_object'];
    $tab['#link']['title'] = [
      '#type' => 'image',
      '#theme' => 'image',
      '#uri' => drupal_get_path('module', 'islandora') . '/images/print-icon.png',
    ];
  }
}

/**
 * Implements hook_islandora_object_alter().
 */
function islandora_islandora_object_alter(AbstractObject $object, array &$context) {
  // Prevent derivative creation during ingest if var is set.
  if ($context['action'] == 'ingest' && \Drupal::config('islandora.settings')->get('islandora_defer_derivatives_on_ingest')) {
    module_load_include('inc', 'islandora', 'includes/derivatives');
    islandora_set_defer_derivatives_flag($object);
  }
}

/**
 * Set property on an entity.
 *
 * Drupal's usual entity_property_verbatim_set() does not work, as tries to use
 * ArrayAccess stuff instead of setting properties directly.
 */
function islandora_entity_set_property(&$data, $name, $value, $langcode) {
  if (is_object($data)) {
    $data->$name = $value;
  }
}

/**
 * Conditionally clear cache to alleviate cache thrashing.
 *
 * If we are responding to form submission or during a batch which ingested,
 * modified or purged an object or datastream, we want to be sure to clear the
 * cache at the end of the process.
 *
 * @param Drupal\Core\Cache\CacheableDependencyInterface $cache_meta
 *   An optional CacheableDependencyInterface object, from which we will grab
 *   the tags and use them to invalidate cache entries.
 */
function islandora_conditionally_clear_cache(CacheableDependencyInterface $cache_meta = NULL) {
  static $clear;
  if (!isset($clear)) {
    $clear =& drupal_static(__FUNCTION__, FALSE);
  }

  if ($cache_meta) {
    Cache::invalidateTags($cache_meta->getCacheTags());
  }

  $functions = [
    // Object changes in response to a form.
    'executesubmithandlers' => 'islandora_cache_clear_all',
    // Object changes in response to a batch. Note that this will not match on
    // a drush batch, as drush uses a different set of functions to run
    // batches. We intentionally do not clear batches in response to drush
    // batches, since they are not in response to GUI actions.
    '_batch_process' => 'islandora_schedule_cache_clear_for_batch',
  ];
  $options = (version_compare(PHP_VERSION, '5.3.6', '>=') ? DEBUG_BACKTRACE_IGNORE_ARGS & ~DEBUG_BACKTRACE_PROVIDE_OBJECT : FALSE);
  foreach (debug_backtrace($options) as $frame) {
    $function_name = strtolower($frame['function']);
    if (isset($functions[$function_name])) {
      $clear = TRUE;
      $function = $functions[$function_name];
      $function();
      return;
    }
  }
}

/**
 * Clear the page and block caches at the end of the request.
 */
function islandora_cache_clear_all() {
  // Advanced "static" handling, as this may be called fairly often.
  static $clear;
  if (isset($clear)) {
    $clear =& drupal_static(__FUNCTION__, FALSE);
  }
  if (!$clear) {
    $clear = TRUE;
    drupal_register_shutdown_function('islandora_shutdown_cache_clear_all');
  }
}

/**
 * Shutdown callback to nuke render cache.
 *
 * This should be made more targeted in the future.
 */
function islandora_shutdown_cache_clear_all() {
  Cache::invalidateTags([
    DefaultController::LISTING_TAG,
  ]);
}

/**
 * Set a batch to clear the page and block caches.
 */
function islandora_schedule_cache_clear_for_batch() {
  $batch =& batch_get();
  static $scheduled;
  $scheduled = isset($scheduled) || isset($batch['islandora_cache_clear_scheduled']);

  if ($scheduled || !isset($batch['id'])) {
    // We do not wish to do anything if we are either already scheduled or the
    // batch is not running.
    return;
  }
  $clear_batch = [
    'operations' => [
      ['islandora_cache_clear_all', []],
    ],
  ];
  batch_set($clear_batch);

  // Set our flag, to avoid setting the batch multiple times during multiple
  // iterations/operations of a single batch.
  $batch['islandora_cache_clear_scheduled'] = TRUE;
}

/**
 * Implements hook_islandora_get_breadcrumb_query_predicates().
 */
function islandora_islandora_get_breadcrumb_query_predicates(AbstractObject $object) {
  return [
    'info:fedora/fedora-system:def/relations-external#isPartOf',
    'info:fedora/fedora-system:def/relations-external#isMemberOfCollection',
    'info:fedora/fedora-system:def/relations-external#isMemberOf',
  ];
}

/**
 * Implements hook_islandora_breadcrumbs_backends().
 */
function islandora_islandora_breadcrumbs_backends() {
  return [
    ISLANDORA_BREADCRUMB_LEGACY_BACKEND => [
      'title' => t('Resource Index - Default'),
      // Callback not needed as this is our legacy process and the
      // default incase anything goes wrong.
    ],
  ];
}

/**
 * Implements hook_islandora_solution_pack_child_relationships().
 */
function islandora_islandora_solution_pack_child_relationships($cmodels) {
  // Return empty arrays from core implementation so that these keys always
  // exist when the hook is called, even if no module responds.
  return ['predicate' => [], 'prefix' => []];
}

/**
 * Implements hook_batch_alter().
 */
function islandora_batch_alter(&$batch) {
  // XXX: Batches performed under Drush 9 do not inherit the user of the
  // caller, and Drush 9's "process.manager" service is not easily
  // overridable so as to be able to override... SO: Let's wrap all batch
  // operations passing through the CLI if they have been submitted as an
  // authenticated user, to make them run as said authenticated user.
  // Somewhat associated with Drush 9's whole dropping-support-for-the-"--user"
  // -argument business...
  // @see https://github.com/drush-ops/drush/issues/3396
  if (PHP_SAPI !== 'cli') {
    return;
  }

  $user = \Drupal::currentUser();
  if (!$user->isAuthenticated()) {
    return;
  }

  $wrap_op = function ($op) use ($user) {
    $func = reset($op);
    return $func !== '_islandora_user_wrapped_batch_op' ?
      [
        '_islandora_user_wrapped_batch_op',
        [
          $user->id(),
          $op,
        ],
      ] :
      $op;
  };

  foreach ($batch['sets'] as &$set) {
    $set['operations'] = array_map($wrap_op, $set['operations']);
  }
  // XXX: Clean up the reference.
  unset($set);
}

/**
 * Wrap batch op with user.
 */
function _islandora_user_wrapped_batch_op($id, $info, &$context) {

  $switcher = \Drupal::service('account_switcher');
  try {
    $user = \Drupal::service('entity_type.manager')->getStorage('user')->load($id);
    $switcher->switchTo($user);

    list($op, $args) = $info;
    return call_user_func_array($op, array_merge($args, [&$context]));
  }
  finally {
    $switcher->switchBack();
  }

}
